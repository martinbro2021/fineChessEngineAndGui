Ideen hashCode

hashCode zusammensetzen aus "Atomen".
Alle Atome zusammen ergeben die aktuelle Spielsituation:
Wer zieht gerade? Welche Figuren auf welchen Positionen stehen auf dem Brett?
Welche Rechte gelten aktuell (En Passant- und Rochade-Rechte)?



Beispiele:
Atome a1 a2 a3... a22

a1: "weißer König auf E2"
...
a17: "schwarzer Turm auf H8"
a18: "weiß am Zug"
a19: "schwarz darf beidseitig rochieren"
...
a22: "schwarzer C-Bauer darf en passant geschlagen werden"


Die meisten Atome ändern sich NICHT durch einen Zug.
Es wäre gut, den hashCode nicht jedes mal neu zu berechnen,
sondern nur für die geänderten Atome.
Außerdem wäre es gut, keine Unterscheidung machen zu müssen, ob ein Atom aus dem hashCode
entfernt wird oder hinzugefügt wird.

Beispiel: Sei h der hashCode. Wir entfernen oder fügen ein Atom dem hashCode hinzu:

h => hash(h, atom) == h'

Wünschenswert auch:
h' => hash(h', atom) == h

also brauchen wir eine Verknüpfung hash(), nennen wir sie "*", mit

h * atom * atom = h    [ = ((h * atom) * atom) = h ]

hash-Funktionen mit Multiplikationen und Additionen kommen nicht infrage.

XOR, die exklusiv-oder-Verknüpfung liefert die gewünschten Eigenschaften!

((h XOR a) XOR a) = h

Beispiel:
    1001
XOR 1100
  = 0101
XOR 1100
  = 1001 voila ;)


Idee:
Jedes mögliche Atom (z.B. zunächst mal 64*6*2 Atome für Figuren und Positionen wie a1 und a17)
bekommt einen 64 bit Zufallswert.

Nennen wir diesen Wert randomValue(atom)

Um ein Atom dem hash hinzuzufügen, brauchen wir nur

h XOR randomValue(atom)

um es zu entfernen auch:

h XOR randomValue(atom)


XOR ist extrem schnell berechnet und wir brauchen den hash nie wieder neu zu berechnen, ein Update durch eine XOR
Operation genügt!